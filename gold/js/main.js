// Generated by CoffeeScript 1.6.2
var Game, Status, game;

Status = (function() {
  function Status() {
    this.gold = null;
    this.totalGold = null;
    this.tax = null;
    this.growth = null;
    this.slimes = null;
    this.lastSlimeText = '';
    this.bestNRed = null;
    this.bestNYellow = null;
    this.bestNGreen = null;
    this.bestNBlue = null;
    this.bestSize = null;
    this.medals = null;
  }

  Status.prototype.sortSlime = function() {
    return this.slimes.sort(function(a, b) {
      if (a.rank !== b.rank) {
        return b.rank - a.rank;
      } else if (a.color !== b.color) {
        return a.color - b.color;
      } else {
        return a.size - b.size;
      }
    });
  };

  return Status;

})();

Game = (function() {
  var beforeTime, composeId, frameCount, load, save, saveSlime, status, update;

  function Game() {}

  status = null;

  composeId = -1;

  frameCount = 0;

  beforeTime = -1;

  Game.prototype.debug = function(gold) {
    status.slimes = [];
    status.gold = gold;
    status.totalGold = gold;
    status.growth = 0;
    status.tax = 0;
    status.medal = [];
    this.setSlimesElement();
    return this.setGrowthElement();
  };

  Game.prototype.reset = function() {
    status.slimes = [];
    status.gold = 0;
    status.totalGold = 0;
    status.growth = 0;
    status.tax = 0;
    save();
    this.setSlimesElement();
    return this.setGrowthElement();
  };

  Game.prototype.init = function() {
    load();
    this.setSlimesElement();
    this.setGrowthElement();
    return setInterval(update, 100);
  };

  load = function() {
    var date, loadTime, saveTime, slimeData, slimeMedals;

    status = new Status();
    status.gold = parseInt(localStorage.getItem('gold'));
    if (!status.gold) {
      status.gold = 0;
    }
    status.totalGold = parseInt(localStorage.getItem('totalGold'));
    if (!status.totalGold) {
      status.totalGold = 0;
    }
    if (status.gold > status.totalGold) {
      status.totalGold = status.gold;
    }
    saveTime = parseInt(localStorage.getItem('time'));
    if (saveTime) {
      date = new Date();
      loadTime = date.getTime();
      status.gold += Math.floor((date.getTime() - saveTime) / 1000);
      status.totalGold += Math.floor((date.getTime() - saveTime) / 1000);
    }
    status.tax = parseInt(localStorage.getItem('tax'));
    if (!status.tax) {
      status.tax = 0;
    }
    status.growth = parseInt(localStorage.getItem('growth'));
    if (!status.growth) {
      status.growth = 0;
    }
    slimeData = localStorage.getItem('slimes');
    if (slimeData && slimeData !== 'undefined' && slimeData !== 'null') {
      console.log(slimeData);
      status.slimes = JSON.parse(slimeData);
    } else {
      status.slimes = [];
    }
    slimeMedals = localStorage.getItem('medals');
    if (slimeMedals && slimeMedals !== 'undefined' && slimeMedals !== 'null') {
      console.log(slimeMedals);
      status.medals = JSON.parse(slimeMedals);
    } else {
      status.medals = [0, 0, 0, 0];
    }
    status.lastSlimeText = localStorage.getItem('lastSlimeText');
    if (status.lastSlimeText === 'null' || status.lastSlimeText === null) {
      status.lastSlimeText = '';
    }
    console.log("load Gold is " + status.gold);
    console.log("load TotalGold is " + status.totalGold);
    status.bestNRed = localStorage.getItem('bestNRed');
    if (!status.bestNRed) {
      status.bestNRed = 0;
    }
    status.bestNYellow = localStorage.getItem('bestNYellow');
    if (!status.bestNYellow) {
      status.bestNYellow = 0;
    }
    status.bestNGreen = localStorage.getItem('bestNGreen');
    if (!status.bestNGreen) {
      status.bestNGreen = 0;
    }
    status.bestNBlue = localStorage.getItem('bestNBlue');
    if (!status.bestNBlue) {
      return status.bestNBlue = 0;
    }
  };

  save = function() {
    var date;

    localStorage.setItem('gold', status.gold);
    localStorage.setItem('totalGold', status.totalGold);
    localStorage.setItem('tax', status.tax);
    localStorage.setItem('growth', status.growth);
    date = new Date();
    localStorage.setItem('time', date.getTime());
    localStorage.setItem('lastSlimeText', status.lastSlimeText);
    localStorage.setItem('bestNRed', status.bestNRed);
    localStorage.setItem('bestNYellow', status.bestNYellow);
    localStorage.setItem('bestNGreen', status.bestNGreen);
    localStorage.setItem('bestNBlue', status.bestNBlue);
    localStorage.setItem('redMedal', status.redMedal);
    localStorage.setItem('yellowMedal', status.yellowMedal);
    localStorage.setItem('breenMedal', status.greenMedal);
    localStorage.setItem('blueMedal', status.blueMedal);
    return localStorage.setItem('medals', JSON.stringify(status.medals));
  };

  update = function() {
    var add, date, elementGold, elementGrowth, elementMedal, elementTotalGold, medal, medalSum, nowTime, _i, _len, _ref;

    ++frameCount;
    date = new Date();
    nowTime = date.getTime();
    if (beforeTime === -1) {
      add = 0.1;
      beforeTime = nowTime;
    } else {
      add = (nowTime - beforeTime) / 1000;
      beforeTime = nowTime;
    }
    status.gold += add;
    status.totalGold += add;
    if (frameCount % 10 === 0) {
      save();
    }
    elementGold = document.getElementById('gold');
    elementGold.innerText = "Gold: " + (Math.floor(status.gold)) + "G";
    elementTotalGold = document.getElementById('total-gold');
    elementTotalGold.innerText = "TotalGold: " + (Math.floor(status.totalGold)) + "G";
    medalSum = 0;
    _ref = status.medals;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      medal = _ref[_i];
      medalSum += medal;
    }
    elementMedal = document.getElementById('medal');
    elementMedal.innerText = medalSum > 0 ? "Slime Medal: " + medalSum : '';
    elementGrowth = document.getElementById('growth');
    return elementGrowth.innerText = "Growth: " + (Math.floor(status.growth));
  };

  Game.prototype.setGrowthElement = function() {
    var appearSlimeStore, elementStore, elementStoreHTML, n;

    elementStore = document.getElementById('store');
    elementStoreHTML = "<ul>";
    if (status.growth >= 10) {
      elementStoreHTML += '<li><input type="button" value="スライムショップ(300G)" onclick="game.getSlime()">';
      if (status.lastSlimeText !== '') {
        elementStoreHTML += '--> ' + status.lastSlimeText;
      }
      elementStoreHTML += '</li>';
      appearSlimeStore = true;
    } else {
      elementStoreHTML += '<li>Growth:10 -> Open</li>';
    }
    if (status.growth >= 20) {
      elementStoreHTML += '<li>スライム合成所</li>';
      appearSlimeStore = true;
    } else {
      elementStoreHTML += '<li>Growth:20 -> Open</li>';
    }
    if (status.growth >= 500) {
      n = Math.min(Math.floor(status.gold / 300), this.getMaxSlimes() - status.slimes.length);
      elementStoreHTML += '<li><input type="button" value="スライムショップ' + ("x" + n + " (" + (300 * n) + "G)") + '" onclick="game.getSlimes(' + n + ')">';
      elementStoreHTML += '</li>';
      appearSlimeStore = true;
    } else {
      elementStoreHTML += '<li>Growth:500 -> Open</li>';
    }
    if (status.growth >= 1000) {
      elementStoreHTML += '<li>メダル交換所 [Normal 1000mm -> Medal]</li>';
    } else {
      elementStoreHTML += '<li>Growth:1000 -> Open</li>';
    }
    if (status.growth >= 2000) {
      elementStoreHTML += '<li><input type="button" value="自動合成(サイズが同じもの)" onclick="game.autoComposeEquals()"></li>';
    } else {
      elementStoreHTML += '<li>Growth: 4000 -> Open</li>';
    }
    if (status.growth >= 4000) {
      elementStoreHTML += '<li><input type="button" value="自動合成(サイズ比が5%未満のもの)" onclick="game.autoComposeNearby(5)"></li>';
    } else {
      elementStoreHTML += '<li>Growth: 4000 -> Open</li>';
    }
    if (status.growth >= 5000) {
      elementStoreHTML += '<li><input type="button" value="自動合成(サイズ比が10%未満のもの)" onclick="game.autoComposeNearby(10)"></li>';
    } else {
      elementStoreHTML += '<li>Growth: 5000 -> Open</li>';
    }
    elementStoreHTML += "</ul>";
    return elementStore.innerHTML = elementStoreHTML;
  };

  Game.prototype.getSlimeText = function(slime) {
    var color, rank;

    color = (function() {
      switch (slime.color) {
        case 0:
          return 'Red';
        case 1:
          return 'Yellow';
        case 2:
          return 'Green';
        case 3:
          return 'Blue';
      }
    })();
    rank = (function() {
      switch (slime.rank) {
        case 0:
          return 'Normal';
        case 1:
          return 'Fine';
        case 2:
          return 'Premium';
      }
    })();
    return "" + rank + " " + color + " " + slime.size + "mm";
  };

  Game.prototype.setBestSlime = function() {
    var slime, _i, _len, _ref;

    _ref = status.slimes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      slime = _ref[_i];
      switch (slime.color) {
        case 0:
          status.bestNRed = Math.max(status.bestNRed, slime.size);
          break;
        case 1:
          status.bestNYellow = Math.max(status.bestNYellow, slime.size);
          break;
        case 2:
          status.bestNGreen = Math.max(status.bestNGreen, slime.size);
          break;
        case 3:
          status.bestNBlue = Math.max(status.bestNBlue, slime.size);
      }
    }
    return status.bestSize = status.bestNRed + status.bestNYellow + status.bestNGreen + status.bestNBlue;
  };

  saveSlime = function() {
    return localStorage.setItem('slimes', JSON.stringify(status.slimes));
  };

  Game.prototype.setSlimesElement = function() {
    var composeSlime, elementSlime, index, slime, slimeHTML, _i, _len, _ref;

    saveSlime();
    this.setBestSlime();
    document.getElementById('best-slime').innerText = 'Best Slime Size Avg. : ' + status.bestSize / 4 + 'mm';
    if (status.slimes.length > 0 && status.growth >= 10) {
      elementSlime = document.getElementById('my-slime');
      slimeHTML = "<h2>Slimes</h2>\n  <form name='slimeButton' action='#'>\n  <p>" + status.slimes.length + " / " + (this.getMaxSlimes()) + "</p>\n  <table>";
      if (composeId !== -1) {
        composeSlime = status.slimes[composeId];
      }
      _ref = status.slimes;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        slime = _ref[index];
        slimeHTML += '<tr>';
        slimeHTML += '<td>' + this.getSlimeText(slime) + '</td>';
        if (status.growth >= 20) {
          slimeHTML += '<td>';
          if (composeId === -1) {
            if (status.slimes[index].size < 1000) {
              slimeHTML += "<input type='button' value='合成' onclick='game.compose(" + index + ")'>";
            } else if (status.growth >= 1000) {
              slimeHTML += "<input type='button' value='メダル交換' onclick='game.getMedal(" + index + ")'>";
            }
            slimeHTML += '</td>';
          } else {
            if (index === composeId) {
              slimeHTML += "<input type='button' value='合成を終了' onclick='game.composeCansel(" + index + ")'>";
            } else if (slime.color === composeSlime.color && slime.rank === composeSlime.rank && slime.size < 1000) {
              slimeHTML += '</td><td>';
              slimeHTML += "<input type='button' value='素材にする(" + (status.slimes[composeId].size + status.slimes[index].size) + "G)' onclick='game.composeStart(" + index + ")'>";
            }
            slimeHTML += '</td>';
          }
        }
        slimeHTML += '</tr>';
      }
      slimeHTML += '</table></form>';
      return elementSlime.innerHTML = slimeHTML;
    }
  };

  Game.prototype.tax = function() {
    var pay;

    pay = Math.floor(status.totalGold / 100) - status.tax;
    if (status.gold >= pay) {
      status.gold -= pay;
      status.tax += pay;
      status.growth += pay;
    } else {
      status.tax += Math.floor(status.gold);
      status.growth += Math.floor(status.gold);
      status.gold -= Math.floor(status.gold);
    }
    this.setGrowthElement();
    return this.setSlimesElement();
  };

  Game.prototype.getMaxSlimes = function() {
    return Math.floor(Math.min(Math.max(50, status.bestSize / 40), 100));
  };

  Game.prototype.getSlimes = function(n) {
    var i, _i, _results;

    _results = [];
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      _results.push(this.getSlime());
    }
    return _results;
  };

  Game.prototype.getSlime = function() {
    var slime;

    if (status.gold < 300) {
      return;
    }
    if (status.slimes.length >= this.getMaxSlimes()) {
      return;
    }
    status.gold -= 300;
    slime = {
      color: Math.floor(Math.random() * 4),
      size: Math.floor(Math.random() * 90) + 10,
      rank: 0
    };
    status.lastSlimeText = this.getSlimeText(slime);
    console.log(status.lastSlimeText);
    status.slimes.push(slime);
    status.sortSlime();
    this.setGrowthElement();
    return this.setSlimesElement();
  };

  Game.prototype.getMedal = function(index) {
    var slime;

    slime = status.slimes[index];
    console.log(slime.rank);
    console.log(slime.color);
    if (slime.rank !== 0) {
      return;
    }
    if (slime.size < 1000) {
      return;
    }
    status.medals[slime.color]++;
    status.slimes.splice(index, 1);
    save();
    this.setGrowthElement();
    return this.setSlimesElement();
  };

  Game.prototype.compose = function(index) {
    if (status.growth < 20) {
      return;
    }
    composeId = index;
    this.setGrowthElement();
    return this.setSlimesElement();
  };

  Game.prototype.autoComposeEquals = function() {
    var baseSlime, composeSlime, index, _results;

    if (status.slimes.length <= 1) {
      return;
    }
    index = 0;
    _results = [];
    while (index < status.slimes.length - 1) {
      index = 0;
      _results.push((function() {
        var _ref, _results1;

        _results1 = [];
        while (index < status.slimes.length - 1) {
          baseSlime = status.slimes[index];
          composeSlime = status.slimes[index + 1];
          if ((baseSlime.rank === (_ref = composeSlime.rank) && _ref === 0)) {
            if (baseSlime.color === composeSlime.color) {
              if (baseSlime.size === composeSlime.size) {
                this.compose(index);
                this.composeStart(index + 1);
                this.composeCansel();
                break;
              }
            }
          }
          _results1.push(++index);
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Game.prototype.autoComposeNearby = function(standardRate) {
    var baseSlime, bestIndex, bestRate, composeSlime, index, rate, _i, _ref, _ref1, _results;

    if (status.slimes.length <= 1) {
      return;
    }
    _results = [];
    while (true) {
      bestRate = 2.0;
      bestIndex = -1;
      for (index = _i = 0, _ref = status.slimes.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; index = 0 <= _ref ? ++_i : --_i) {
        baseSlime = status.slimes[index];
        composeSlime = status.slimes[index + 1];
        if ((baseSlime.rank === (_ref1 = composeSlime.rank) && _ref1 === 0) && baseSlime.color === composeSlime.color && composeSlime.size < 1000) {
          rate = composeSlime.size / baseSlime.size;
          if (bestRate > rate) {
            bestRate = rate;
            bestIndex = index;
          }
        }
      }
      console.log(bestIndex + ',' + bestRate);
      if (bestRate <= (100 + standardRate) / 100) {
        if (status.slimes[bestIndex].size + status.slimes[bestIndex + 1].size > status.gold) {
          break;
        }
        this.compose(bestIndex);
        this.composeStart(bestIndex + 1);
        _results.push(this.composeCansel());
      } else {
        break;
      }
    }
    return _results;
  };

  Game.prototype.composeCansel = function(index) {
    composeId = -1;
    status.sortSlime();
    this.setGrowthElement();
    return this.setSlimesElement();
  };

  Game.prototype.composeStart = function(index) {
    var pay, size_first, size_second;

    size_first = status.slimes[composeId].size;
    size_second = status.slimes[index].size;
    pay = size_first + size_second;
    if (status.slimes[index].rank !== status.slimes[composeId].rank) {
      return;
    }
    if (status.slimes[index].color !== status.slimes[composeId].color) {
      return;
    }
    if (status.gold < pay) {
      return;
    }
    status.gold -= pay;
    status.slimes[composeId].size = Math.floor(Math.sqrt(size_first * size_first + size_second * size_second));
    status.slimes.splice(index, 1);
    if (composeId > index) {
      --composeId;
    }
    this.setGrowthElement();
    return this.setSlimesElement();
  };

  return Game;

})();

game = null;

window.onload = function() {
  game = new Game();
  return game.init();
};
